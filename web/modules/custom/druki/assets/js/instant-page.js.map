{"version":3,"sources":["druki/assets/js/instant-page.es6.js"],"names":["Drupal","blackList","behaviors","drukiInstantPage","attach","context","settings","this","blackListHandler","trigger","window","requestIdleCallback","callback","intersectionObserver","IntersectionObserver","entries","forEach","entry","isIntersecting","linkElement","target","unobserve","processBlackListLink","querySelectorAll","observe","origin","location","regexp","join","pathname","match","dataset","noInstant"],"mappings":"CAMA,SAAWA,GAET,aAcA,MAAMC,EAAY,CAChB,cACA,eACA,gCACA,oCAGFD,EAAOE,UAAUC,iBAAmB,CAClCC,OAAQ,SAAUC,EAASC,GACzBC,KAAKC,iBAAiBH,IAMxBG,iBAAkB,SAAUH,GAC1B,IAAII,EAEFA,EADEC,OAAOC,oBACEC,IACTD,oBAAoBC,IAKXA,IACTA,KAIJH,GAAQ,KACN,MAAMI,EAAuB,IAAIC,sBAAsBC,IACrDA,EAAQC,SAASC,IACf,GAAIA,EAAMC,eAAgB,CACxB,MAAMC,EAAcF,EAAMG,OAC1BP,EAAqBQ,UAAUF,GAC/BZ,KAAKe,qBAAqBH,UAKhCd,EAAQkB,iBAAiB,KAAKP,SAASG,IACrCN,EAAqBW,QAAQL,UAQnCG,qBAAsB,SAAUH,GAE9B,GAAIA,EAAYM,QAAUC,SAASD,OACjC,OAIF,MAAME,EAAS,OAAS1B,EAAU2B,KAAK,KAAO,KAE1CT,EAAYU,SAASC,MAAMH,KAC7BR,EAAYY,QAAQC,WAAY,KA3ExC,CAgFGhC","file":"instant-page.js","sourcesContent":["/**\n * @file\n * Provides wrapper for instant.page library.\n *\n * @see https://instant.page/\n */\n(function (Drupal) {\n\n  'use strict';\n\n  /**\n   * The list of patterns with blacklisted links.\n   *\n   * Some links don't need to be prefetch in any situation. F.e. /user/logout\n   * prefetch will logout user without it noticing and intention. But when page\n   * will be changed or refreshed he will be anonymous user.\n   *\n   * Also it's a good to to exclude pages which will redirect as their response.\n   * This just not make sense to preload.\n   *\n   * This list contains JavaScript regexp patterns.\n   */\n  const blackList = [\n    '\\/user\\/login',\n    '\\/user\\/logout',\n    '\\/druki_content\\/.*\\/edit-remote',\n    '\\/druki_content\\/.*\\/history-remote',\n  ];\n\n  Drupal.behaviors.drukiInstantPage = {\n    attach: function (context, settings) {\n      this.blackListHandler(context);\n    },\n\n    /**\n     * Handles black listed links in CPU intense free mode.\n     */\n    blackListHandler: function (context) {\n      let trigger;\n      if (window.requestIdleCallback) {\n        trigger = (callback) => {\n          requestIdleCallback(callback)\n        }\n      }\n      else {\n        // Fallback for browsers doesn't support IDLE callbacks.\n        trigger = (callback) => {\n          callback()\n        }\n      }\n\n      trigger(() => {\n        const intersectionObserver = new IntersectionObserver((entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              const linkElement = entry.target;\n              intersectionObserver.unobserve(linkElement);\n              this.processBlackListLink(linkElement);\n            }\n          })\n        });\n\n        context.querySelectorAll('a').forEach((linkElement) => {\n          intersectionObserver.observe(linkElement);\n        })\n      });\n    },\n\n    /**\n     * Process link and disable prefetch if it's blacklisted.\n     */\n    processBlackListLink: function (linkElement) {\n      // Support only for internal links. External not prefetched at all.\n      if (linkElement.origin != location.origin) {\n        return;\n      }\n\n      // Build regexp.\n      const regexp = '^(?:' + blackList.join('|') + ')$';\n\n      if (linkElement.pathname.match(regexp)) {\n        linkElement.dataset.noInstant = true;\n      }\n    }\n  };\n\n})(Drupal);\n"]}